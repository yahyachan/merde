# 测试计划
## 1 引言
### 1.1 编写目的
本文档的目的为制定软件详细的需求规格说明，以支持项目的后续开发。

本文档的主要预期读者为项目组开发人员，以及期望对软件做出贡献者。

### 1.2 背景
这里待开发的软件系统名为可扩展函数式程序设计语言 Merde。

本项目为湛忠胜所提出，开发者为湛忠胜、叶文、郭明昊。该软件在个人笔记本电脑上实现。

### 1.3 定义

### 1.4 参考资料
1. 软件需求说明书
2. 概要设计说明书

## 2 计划
### 2.1 软件说明
软件的结构如下：

![结构图](../../img/gy_struct.drawio.png)

#### 输入、处理和输出
要求输入为用户程序（字符串的形式），经过如下的处理：

1. 词法分析
2. 语法分析
3. 类型推导和类型检查
4. 解释

最终输出为类型和求值结果，二者都以字符串的形式返回给用户。

#### 软件功能需求
我们这里简述一下本软件的六大功能需求，具体需求分析请看《软件需求说明书》：

1. 语言层面支持可扩展函数式编程特性
2. 类型系统中要能对可扩展函数式编程建模
3. 类型系统中要能支持基本的泛型（let polymorphism）
4. 类型推导输出的类型必须是用户输入能对应的**最优**类型
5. 输出的求值结果反映用户的要求
6. 对于用户输入程序有错误的情况，要返回详尽的错误信息

### 2.2 测试内容
测试内容按顺序来说有如下几项（进度安排会在后面几节给出）：

1. 对词法解析器的测试（`test_lexer`），为对词法分析（`Lexer`）模块进行的单元测试。
2. 解释测试（`untyped`），为对解释（`Interpret`）模块进行的单元测试。
3. 推导测试（`test_infer`），为对双向类型检查（`Reconstruction`）模块进行的单元测试。
4. 整个系统的集成测试（`combine_parser`），是整个系统中所有模块的集成测试。
5. 整个系统的确认测试。

可以看出这里的集成测试是一种自底向上和自顶向下的结合。以上所有测试皆为黑盒测试，都将输入数据划分成若干等价类，使用每个等价类的典型输入数据进行测试。

### 2.3 对词法解析器的测试（test_lexer）
本项测试为对词法分析（`Lexer`）模块进行的黑盒单元测试。

#### 2.3.1 进度安排
预计在 2023.5.14 进行。

#### 2.3.2 条件
本测试所用设备为个人笔记本电脑，所用测试框架为 OUnit 2.2.6，对人员没有特别要求。

#### 2.3.3 测试资料
本测试针对的模块为`Lexer`，测试程序及其相关输入输出皆在`test/test_lexer.ml`文件中。

#### 2.3.4 测试培训
无特殊要求。

### 2.4 解释测试（untyped）
本项测试为对解释（`Interpret`）模块进行的黑盒单元测试。

#### 2.4.1 进度安排
预计在 2023.5.21 进行。

#### 2.4.2 条件
本测试所用设备为个人笔记本电脑，所用测试框架为 OUnit 2.2.6，对人员没有特别要求。

#### 2.4.3 测试资料
本测试针对的模块为`Interpret`，测试程序及其相关输入输出皆在`test/untyped.ml`文件中。

#### 2.4.4 测试培训
无特殊要求。

### 2.5 推导测试（test_infer）
本项测试为对双向类型检查（`Reconstruction`）模块进行的黑盒单元测试。

#### 2.5.1 进度安排
预计在 2023.5.28 进行。

#### 2.5.2 条件
本测试所用设备为个人笔记本电脑，所用测试框架为 OUnit 2.2.6，对人员没有特别要求。

#### 2.5.3 测试资料
本测试针对的模块为`Reconstruction`，测试程序及其相关输入输出皆在`test/test_infer.ml`文件中。

#### 2.5.4 测试培训
无特殊要求。

### 2.6 集成测试（`combine_parser`）
本项测试为集成系统中所有模块的测试。

#### 2.6.1 进度安排
预计在 2023.5.29 进行。

#### 2.6.2 条件
本测试所用设备为个人笔记本电脑，所用测试框架为 OUnit 2.2.6，对人员没有特别要求。

#### 2.6.3 测试资料
本测试集成了系统中所有模块，测试程序及其相关输入输出皆在`test/combine_parser.ml`文件中。

#### 2.6.4 测试培训
无特殊要求。

### 2.7 确认测试
#### 2.7.1 进度安排
预计在 2023.5.30 进行。

#### 2.7.2 条件
本测试所用设备为个人笔记本电脑，对人员没有特别要求。

#### 2.7.3 测试资料
本测试集成了系统中所有模块。

#### 2.7.4 测试培训
无特殊要求。

## 3 测试设计说明
### 3.1 对词法解析器的测试（test_lexer）
本项测试为对词法分析（`Lexer`）模块进行的黑盒单元测试。

为了方便测试词法分析器的能力，我们在测试文件中设计了`continious_lex`函数，其对输入的字符串不断用词法分析器取单词，直到取到`EOF`（也就是字符串结尾）为止，将取到的实际单词形成一个列表返回，如果出错则报错。

#### 3.1.1 控制
本测试是自动进行的。

#### 3.1.2 输入
我们将可能的输入划分成如下几个等价类，来分别给出典型输入：

##### 输入字符串（实际上）为空的情况（test_empty）
1. `continious_lex ""`
2. `continious_lex "  \t\n\n\t\r\n\r"`

##### 输入字符串都可识别（test_ok）
1. `continious_lex "())in,let_ _1Ma->=="`

##### 输入字符串不一定可识别（test_fail）
1. `continious_lex ";"`

#### 3.1.3 输出
我们还是按照等价类标识情况给出输出：

##### test_empty
都为`[]`。

##### test_ok
为`[LPAREN; RPAREN; RPAREN; IN; COMMA; VARIABLE "let_"; VARIABLE "_1Ma"; SARROW; EQUAL; EQUAL]`。

##### test_fail
报错。

#### 3.1.4 过程
只需要在代码目录下执行`dune runtest`命令就可以自动进行测试。

### 3.2 解释测试（untyped）
本项测试为对解释（`Interpret`）模块进行的黑盒单元测试。

为了方便测试，我们令`let ev = eval Env.empty`。而且所有测试数据都使用了`Syntax.For_test`模块中的EDSL。

#### 3.2.1 控制
本测试是自动进行的。

#### 3.2.2 输入
我们将可能的输入划分成如下几个等价类，来分别给出典型输入：

##### 输入为基本运算类表达式（test_arith）
1. `(ev (eint 3 + eint 1))`
2. `(ev (eint 5 - eint 7))`
3. `(ev (eint 6 * eint 3))`
4. `(ev (eint 21 / eint 3))`
5. `(ev (eint 2 = eint 2))`
6. `(ev (eint 3 = eint 2))`
7. `(ev (eint 2 < eint 3))`
8. `(ev (eint 3 < eint 3))`

##### 输入为条件判断表达式（test_if）
1. `(ev @@ eif (ebool true) (eint 1) (eint 2))`
2. `(ev @@ eif (ebool false) (eint 1) (eint 2))`

##### 输入为需要设定局部变量的表达式（test_let）
1. `ev @@ elet "x" (eint 4) @@ elet "y" (eint 5) @@ elet "z" (eint 3) @@ Infix.(var "x" * var "y" - var "z")`
2. `ev @@ elet "b" (ebool false) @@ eif (var "b") (eint 17) (eint 19)`

##### 输入为涉及递归的表达式（test_fix）
输入前我们先需要定义如下几个辅助函数：
```ocaml
let zfix = efun "g" @@ apply (efun "x" @@ apply (var "x") (var "x")) @@
  efun "z" @@ apply (var "g") @@ efun "v" @@
  apply (apply (var "z") (var "z")) (var "v")

let factorial_z = apply zfix @@ efun "f" @@ efun "x" @@
  eif Infix.((var "x") < (eint 1)) (eint 1) @@
  Infix.(var "x" * apply (var "f") (var "x" - eint 1))

let factorial = efix "f" @@ efun "x" @@
  eif Infix.((var "x") < (eint 1)) (eint 1) @@
  Infix.(var "x" * apply (var "f") (var "x" - eint 1))

let rec fact = function
  | 0 -> 1
  | n -> n * fact (n - 1)
```
可以看出`zfix`为 Z 组合子不动点在 Merde 语言中的表示（注意表示 Z 组合子不动点同时也体现了函数式编程的需求），`factorial_z`为利用`zfix`实现的递归求阶乘的函数，`factorial`为利用 Merde 语言自身递归机制实现的递归求阶乘函数，`fact`为 OCaml 语言中的递归求阶乘函数。

然后对于$i=0,1,2,\ldots,10$，我们分别输入`(ev @@ apply factorial_z (eint i))`和`(ev @@ apply factorial (eint i))`做测试。

##### 涉及可扩展编程的表达式（test_record）
令`th`为`["a", [eint 1; ebool true]; "c", [eint 3]; "b", [ebool false; eint 2]] |> List.to_seq |> Env.of_seq |> erecord`，开始测试：
1. `ev @@ select th "a"`
2. `ev @@ select th "b"`
3. `ev @@ select th "c"`

接下来令`th`为`remove th "a"`，继续测试：

4. `ev @@ select th "a"`

再令`th`为`ext (Env.singleton "a" [eint 114]) th`，继续测试：

5. `ev @@ select th "a"`

#### 3.2.3 输出
我们还是按照等价类标识情况给出输出：
##### test_arith
1. `VInt 4`
2. `VInt (-2)`
3. `VInt 18`
4. `VInt 7`
5. `VBool true`
6. `VBool false`
7. `VBool true`
8. `VBool false`

##### test_if
1. `VInt 1`
2. `VInt 2`

##### test_let
1. `VInt 17`
2. `VInt 19`

##### test_fix
每个$i=0,1,2,\ldots,10$的求值结果等于`VInt (fact i)`。

##### test_record
1. `VInt 1`
2. `VBool false`
3. `VInt 3`
4. `VBool true`
5. `VInt 114`

#### 3.2.4 过程
只需要在代码目录下执行`dune runtest`命令就可以自动进行测试。

### 3.3 推导测试（test_infer）
本项测试为对双向类型检查（`Reconstruction`）模块进行的黑盒单元测试。

为了方便测试，我们令`let infer = reconstruct_toplevel Env.empty`。而且所有测试数据都使用了`Syntax.For_test`模块中的EDSL。此外需要注意的是，泛型类型间的判定是不能直接用结构化等价判定的，而是需要寻找二者类型变量的对应关系再比较，细节见`type_equal`函数。

#### 3.3.1 控制
本测试是自动进行的。

#### 3.3.2 输入
我们将可能的输入划分成如下几个等价类，来分别给出典型输入：

##### 基础类型及其运算（test_base）
1. `infer (eint 114)`
2. `infer (eint 514)`
3. `infer (ebool true)`
4. `infer (ebool false)`
5. `infer (eint 114 - eint 200)`
6. `infer (eint 114 < eint 514)`
7. `infer (eint 1 * ebool true)`
8. `infer (eint 114 = eint 114)`
9. `infer (ebool true = ebool true)`

##### 简单泛型（test_simple_poly）
1. `infer (efun "x" @@ var "x")`
2. `infer (lfun ["s"; "t"; "f"] @@ lapply (var "f") [var "s"; var "t"])`

##### 复杂泛型（test_let_poly）
`infer (elet "p" (lfun ["s"; "t"; "f"] @@ lapply (var "f") [var "s"; var "t"]) @@ efun "s" @@ elet "f" (apply (var "p") (var "s")) @@ lapply (var "p") [apply (var "f") (eint 1); apply (var "f") (ebool true)])`

这一个输入涉及了类型推导以及函数式编程中的很多细节，包括对 let polymorphism 的正确实现、正确的填入泛型变量等等。

##### 递归（test_rec）
1. `infer (efix "f" @@ efun "x" @@ apply (var "f") (var "x"))`
2. `infer (efix "f" @@ efun "x" @@ var "f")`

##### 可扩展编程（test_record）
1. `infer rempty`
2. `infer (select rempty "x")`
3. `infer (efun "r" @@ elet "r" (remove (var "r") "x") @@ select (var "r") "x")`
4. `infer (efun "r" @@ eif (ebool true) (ext (Env.singleton "x" [eint 2]) (var "r")) (ext (Env.singleton "y"  [eint 2]) (var "r")))`
5. `infer (apply (efun "r" @@ elet "r" (remove (var "r") "x") @@ select (var "r") "x") (erecord @@ map_of_assoc_list ["y", [ebool false]; "x", [eint 2; ebool true]]))`

#### 3.3.3 输出
我们还是按照等价类标识情况给出输出：

##### test_base
1. `TInt`
2. `TInt`
3. `TBool`
4. `TBool`
5. `TInt`
6. `TBool`
7. 报错：类型不匹配
8. `TBool`
9. 报错：类型不匹配

##### test_simple_poly
1. `(TFun (TVar 0, TVar 0))`
2. `(TFun (TVar 0, TFun (TVar 1, TFun (TFun (TVar 0, (TFun (TVar 1, TVar 2))), TVar 2))))`

##### test_let_poly
`(TFun (TVar 1, TFun (TFun (TFun (TFun (TVar 1, TFun (TInt, TVar 16)), TVar 16), TFun (TFun (TFun (TVar 1, TFun (TBool, TVar 19)), TVar 19), TVar 13)), TVar 13)))`

##### test_rec
1. `(TFun (TVar 0, TVar 1))`
2. 报错：类型自递归

##### test_record
1. `(TRecord TRowEmpty)`
2. 报错：类型不匹配
3. `(TFun (TRecord (TRowExtension (Env.singleton "x" [TVar 114; TVar 514], TVar 1919)), TVar 514))`
4. 报错：类型不匹配
5. `TBool`

#### 3.3.4 过程
只需要在代码目录下执行`dune runtest`命令就可以自动进行测试。

### 3.4 集成测试（combine_parser）
本项测试实际上为集成系统中所有模块的测试。

在这个测试中，我们给定的输入都是字符串形式的程序表达式，经过词法分析、语法分析、双向类型检查、求值，最后通过值输出和类型输出函数以字符串的形式输出。不过我们这里预期输出会有两种形式：一种是单纯的字符串，表示上面的输出应和这个字符串对应的求出值和类型一致；另一种会是给出类型和值的元组，表示输出类型、值分别和这个元组对应。

#### 3.4.1 控制
本测试是自动进行的。

#### 3.4.2 输入
我们将可能的输入划分成如下几个等价类，来分别给出典型输入：
##### 基础类型及其运算（test_base）
1. `"3 + 1"`
2. `"6 * 3"`
3. `"21 /3"`
4. `"115 * 2 - 116"`
5. `"2 = 2"`
6. `"2 = 3"`
7. `"2 < 3"`
8. `"3 < 3"`
9. `"1 * true"`
10. `"true = true"`

##### 条件判断（test_if）
1. `"if 2 < 2 then 1 else 2"`
2. `"if 2 < 3 then 1 else 2"`
3. `"if true then 1 else true"`

##### 涉及中间变量的情形（test_let）
1. `"let x = 3 in let y = 4 in let z = 5 in x * y - z"`
2. `"let b = true in if b then 114 else 514"`
3. `"let pair = fun x y f => f x y in fun s => let f = pair s in pair (f 1) (f true)"`

##### 涉及递归的情形（test_rec）
1. 首先对于所有$i=0,1,2,\ldots,10$，在`"let fact = fix f => fun x => if x = 0 then 1 else x * f (x - 1) in fact "`后面分别拼接上`i`送入测试。
2. `"fix f => fun x => f"`

##### 可扩展编程（test_record）
1. `"{   }"`
2. `"{ a = 1, c = 3, a = true, b = false, b = 2 }.a"`
3. `"{ a = 1, c = 3, a = true, b = false, b = 2 }.c"`
4. `"{ a = 1, c = 3, a = true, b = false, b = 2 }.b"`
5. `"{{ a = 1, c = 3, a = true, b = false, b = 2 } - a}.a"`
6. `"{a = 114 | {{ a = 1, c = 3, a = true, b = false, b = 2 } - a}}.a"`
7. `"{}.x"`
8. `"fun r => if true then {x=2 | r} else {y=2 | r}"`
9. `"let get_sec = fun r => let r = {r - a} in r.a in get_sec {a = 114 | {{ a = 1, c = 3, a = true, b = false, b = 2 } - a}}"`

##### 语法不正确的情况（test_parser_fail）
1. `""`
2. `"let x =1 in"`
3. `"a, b"`
4. `"()"`
5. `"fun a, b => b"`
6. `"{"`
7. `"{m - a"`
8. `"{a | m}"`

#### 3.4.3 输出
我们还是按照等价类标识情况给出输出：
##### test_base
1. `"4"`
2. `"18"`
3. `"7"`
4. `"114"`
5. `"true"`
6. `"false"`
7. `"true"`
8. `"false"`
9. 报错：类型不匹配
10. 报错：类型不匹配

##### test_if
1. `"2"`
2. `"1"`
3. 报错：类型不匹配

##### test_let
1. `"7"`
2. `"114"`
3. `(PolyType ([1;16;19;13], TFun (TVar 1, TFun (TFun (TFun (TFun (TVar 1, TFun (TInt, TVar 16)), TVar 16), TFun (TFun (TFun (TVar 1, TFun (TBool, TVar 19)), TVar 19), TVar 13)), TVar 13))), VClosure (Env.empty, "s", For_test.rempty))`

##### test_rec
1. 分别和$0!,1!,2!,\ldots,10!$对应即可。
2. 报错：类型自递归

##### test_record
1. `"1"`
2. `"3"`
3. `"false"`
4. `"true"`
5. `"114"`
6. 报错：类型不匹配
7. 报错：类型不匹配
8. `"true"`

##### test_parser_fail
全部都应该报语法错误。

#### 3.4.4 过程
只需要在代码目录下执行`dune runtest`命令就可以自动进行测试。

### 3.5 确认测试
本项测试为软件的确认测试。
#### 3.5.1 控制
本测试是人工测试。

#### 3.5.2 输入
向用户界面直接输入：
```ocaml
let nil = fun pack => pack.Nil;;
let cons = fun x xs pack => pack.Cons x (xs pack);;
let l = cons 1 (cons 2 (cons 3 nil));;
let map = fun f => { Nil = nil, Cons = fun x xs => cons (f x) xs };;
let r = l (map (fun x => x * 2));;
let reduce = fun f init => { Nil = init, Cons = f };;
l (reduce (fun x y => x + y) 0);;
r (reduce (fun x y => x + y) 0);;
l (reduce (fun x y => x * y) 1);;
r (reduce (fun x y => x * y) 1);;
#q ;;
```

#### 3.5.3 输出
```ocaml
val nil : {Nil : 'b; 'a} -> 'b = <fun>
val cons : 'a -> ({Cons : 'a -> 'd -> 'b; 'c} -> 'd) -> {Cons : 'a -> 'd -> 'b; 'c} -> 'b = <fun>
val l : {Cons : int -> 'a -> 'a; Nil : 'a; 'b} -> 'a = <fun>
val map : ('a -> 'e) -> {Cons : 'a -> ({Cons : 'e -> 'c -> 'd; 'b} -> 'c) -> {Cons : 'e -> 'c -> 'd; 'b} -> 'd; Nil : {Nil : 'g; 'f} -> 'g; } = <fun>
val r : {Cons : int -> 'a -> 'a; Nil : 'a; 'b} -> 'a = <fun>
val reduce : 'a -> 'b -> {Cons : 'a; Nil : 'b; } = <fun>
val - : int = 6
val - : int = 12
val - : int = 6
val - : int = 48
Byebye!
```

#### 3.5.4 过程
首先用`dune build`命令编译，将可执行文件交付用户，用户运行可执行文件，不断输入命令，输入最后一条命令后即结束。

## 4 评价准则
### 4.1 范围
测试范围涵盖了解释器的各模块，输入用例包含了语言中的几乎所有典型构造。

不足之处暂无。

### 4.2 数据整理
都是自动的。

### 4.3 尺度
对于`combine_parser`和`test_infer`的测试输出结果和预期输出结果比较标准在3.4节和3.3节中说过了，其余测试要求测试输出结果和预期输出结果完全一样才能通过。